<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>星空例子特效</title>
</head>
<body>
  <canvas id="canvas" width="300" height="300"></canvas>
  <script>
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');


    /*particles:存放粒子，edegs：存放粒子距离*/
    var W, H, particles = [], edegs = [];
    var mouse = {x: 0, y: 0}  //固定不绘制的粒子的坐标

    /*窗口调整，canvas都会充满整个窗口*/
    window.onresize = function(){
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
      if(!particles.length){
        createPatricles()
      }
    };

    /*生成粒子的函数*/
    function createPatricles(){
      for(var i=0; i<150; i++){
        var p = {
          drawable: i == 0, //根据此属性来判断是否绘制粒子
          x: Math.random() * W,
          y: Math.random() * H,
          vx: (Math.random() - 0.5) * 2,  //横向速度
          vy: (Math.random() - 0.5) * 2,  //纵向速度
          r: Math.random() > 0.9 ? Math.random() * 2 + 2 : Math.random() * 2 + 0.1 //半径大小的几率
        };
        particles.push(p)
      }

      var len = particles.length;

      /*生成所有粒子组*/
      for(var i=0; i<len; i++){
        for(var j=i+1; j<len; j++){
          var edeg = {
            start:particles[i],
            end:particles[j]
          }
          edegs.push(edeg)
        }
      }
      console.log(edegs);
    };

    /*给粒子添加运动效果*/
    function update(){
      particles.forEach(function(item){
        if(item.drawable) return false; //未绘制的粒子不运动

        item.x += item.vx;
        item.y += item.vy;

        if(item.x - item.r < 0 || item.x + item.r > W){
          item.vx *= -1;  //达到限制点反向运动
        }

        if(item.y - item.r < 0 || item.y + item.r > H){
          item.vy *= -1;  //达到限制点反向运动
        }
      });
    };


    function draw(){
       /*绘制粒子间的线条*/
      edegs.forEach(function(item){
        var l = distance(item);
        var w = W / 8;  //把屏幕分成8份
        if(l > w){
          return false;
        }

        /*粒子间的距离小于每份的距离时绘制线条*/
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,1)';
        ctx.lineWidth = (1 - l/w) * 2.5;
        ctx.globalAlpha = 1 - l/w;
        ctx.beginPath();
        ctx.moveTo(item.start.x, item.start.y);
        ctx.lineTo(item.end.x, item.end.y);
        ctx.stroke();
        ctx.restore();
      });

      /*绘制粒子*/
      particles.forEach(function(item){
        if(item.drawable){
          return false; //不绘制的粒子
        }
        ctx.save();
        ctx.beginPath();
        ctx.arc(item.x, item.y, item.r, 0, 2*Math.PI);
        ctx.fill();
        ctx.restore();
      });
    };

    /*求出粒子间的距离*/
    function distance(item){
      var x = Math.pow(item.start.x - item.end.x, 2);
      var y = Math.pow(item.start.y - item.end.y, 2);
      return Math.sqrt(x + y);
    };

    /*没有绘制的粒子的坐标*/
    function renderFirstNodes(){
      particles[0].x += (mouse.x - particles[0].x) / 10;  //减速运动方程式
      particles[0].y += (mouse.y - particles[0].y) / 10;
    };

    /*没有绘制的粒子的坐标随鼠标移动*/
    canvas.addEventListener('mousemove', function(e) {
      mouse.x = e.offsetX;
      mouse.y = e.offsetY;
    });

    /*所有内容绘制出来*/
    function render(){
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
      update();
      renderFirstNodes();
      draw();
      requestAnimationFrame(arguments.callee);
    };
    window.onresize();
    render();










  </script>
</body>
</html>
